name: Notify Release

on:
  workflow_run:
    workflows: ["Build and Release"]
    types:
      - completed
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}
    steps:
      - name: Cloning repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get Latest Tag
        id: get_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            echo "No tags found"
            exit 1
          fi
          
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
          echo "Latest tag: $LATEST_TAG"
          
      - name: Get Release Information
        id: get_release
        run: |
          RELEASE_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ env.LATEST_TAG }}")
          
          echo "$RELEASE_DATA" | jq -r '.body' > release_notes.txt
          
          echo "FORMATTED_NOTES<<EOF" >> $GITHUB_ENV
          cat release_notes.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          echo "Release notes fetched successfully"

      - name: Get All Release Assets
        id: get_assets
        run: |
          curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ env.LATEST_TAG }}" -o release.json
          
          bytes_to_hr() {
            awk -v size="$1" 'BEGIN{
              split("B KB MB GB", unit);
              for (i=1; size>=1024 && i<4; i++) size/=1024;
              printf "%.2f %s", size, unit[i]
            }'
          }
          
          echo "Processing assets..."
          
          # Initialize all asset variables
          APK_UNIVERSAL=""
          APK_ARM64=""
          APK_ARM32=""
          APK_X86=""
          WINDOWS_SETUP=""
          WINDOWS_PORTABLE=""
          LINUX_DEB=""
          LINUX_RPM=""
          LINUX_FLATPAK=""
          LINUX_PORTABLE=""
          
          # Parse each asset
          while IFS= read -r line; do
            ASSET_URL=$(echo "$line" | jq -r '.browser_download_url')
            ASSET_SIZE=$(echo "$line" | jq -r '.size')
            FILE_NAME=$(basename "$ASSET_URL")
            SIZE_HR=$(bytes_to_hr "$ASSET_SIZE")
            
            # Categorize assets
            case "$FILE_NAME" in
              *universal*.apk)
                APK_UNIVERSAL="[Universal APK]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *arm64-v8a*.apk)
                APK_ARM64="[ARM64 APK]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *armeabi-v7a*.apk)
                APK_ARM32="[ARM32 APK]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *x86_64*.apk)
                APK_X86="[x86_64 APK]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *.exe)
                WINDOWS_SETUP="[Windows Installer]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *windows*portable*.zip)
                WINDOWS_PORTABLE="[Windows Portable]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *.deb)
                LINUX_DEB="[Linux DEB]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *.rpm)
                LINUX_RPM="[Linux RPM]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *.flatpak)
                LINUX_FLATPAK="[Linux Flatpak]($ASSET_URL) \`$SIZE_HR\`"
                ;;
              *linux*x64*.zip)
                LINUX_PORTABLE="[Linux Portable]($ASSET_URL) \`$SIZE_HR\`"
                ;;
            esac
          done < <(jq -c '.assets[]' release.json)
          
          # Export all variables to GitHub ENV
          echo "APK_UNIVERSAL=$APK_UNIVERSAL" >> $GITHUB_ENV
          echo "APK_ARM64=$APK_ARM64" >> $GITHUB_ENV
          echo "APK_ARM32=$APK_ARM32" >> $GITHUB_ENV
          echo "APK_X86=$APK_X86" >> $GITHUB_ENV
          echo "WINDOWS_SETUP=$WINDOWS_SETUP" >> $GITHUB_ENV
          echo "WINDOWS_PORTABLE=$WINDOWS_PORTABLE" >> $GITHUB_ENV
          echo "LINUX_DEB=$LINUX_DEB" >> $GITHUB_ENV
          echo "LINUX_RPM=$LINUX_RPM" >> $GITHUB_ENV
          echo "LINUX_FLATPAK=$LINUX_FLATPAK" >> $GITHUB_ENV
          echo "LINUX_PORTABLE=$LINUX_PORTABLE" >> $GITHUB_ENV
          
          echo "Assets processed successfully"

      - name: Format Release Notes for Discord
        id: format_discord
        run: |
          # Convert markdown to Discord format with clickable links
          DISCORD_NOTES=$(cat release_notes.txt | \
            sed -E 's/### (.*)/\n**\1**\n/g' | \
            sed -E 's|\* \[([a-f0-9]+)\]\((https://github.com/[^)]+)\): (.*)|\‚Ä¢ [\1](\2) \3|g' | \
            sed 's/||//g' | \
            sed 's/---.*//g')
          
          CHAR_COUNT=${#DISCORD_NOTES}
          echo "Changelog character count: $CHAR_COUNT"
          
          # Discord embed description limit is 4096 chars
          if [ $CHAR_COUNT -gt 3900 ]; then
            echo "‚ö†Ô∏è Changelog too long ($CHAR_COUNT chars), truncating smartly..."
            
            # Extract sections
            FEATURES=$(echo "$DISCORD_NOTES" | sed -n '/\*\*.*New Features/,/\*\*[^N]/p' | head -n -1 || echo "")
            FIXES=$(echo "$DISCORD_NOTES" | sed -n '/\*\*.*Bug Fixes/,/\*\*[^B]/p' | head -n -1 || echo "")
            REFACTORS=$(echo "$DISCORD_NOTES" | sed -n '/\*\*.*Refactors/,/\*\*[^R]/p' | head -n -1 || echo "")
            STYLE=$(echo "$DISCORD_NOTES" | sed -n '/\*\*.*Style/,/\*\*[^S]/p' | head -n -1 || echo "")
            PERF=$(echo "$DISCORD_NOTES" | sed -n '/\*\*.*Performance/,/\*\*[^P]/p' | head -n -1 || echo "")
            CHORES=$(echo "$DISCORD_NOTES" | sed -n '/\*\*.*Chores/,/\*\*[^C]/p' | head -n -1 || echo "")
            
            # Count items in each section
            FEATURE_COUNT=$(echo "$FEATURES" | grep -c "^‚Ä¢" 2>/dev/null || echo "0")
            FIX_COUNT=$(echo "$FIXES" | grep -c "^‚Ä¢" 2>/dev/null || echo "0")
            REFACTOR_COUNT=$(echo "$REFACTORS" | grep -c "^‚Ä¢" 2>/dev/null || echo "0")
            STYLE_COUNT=$(echo "$STYLE" | grep -c "^‚Ä¢" 2>/dev/null || echo "0")
            PERF_COUNT=$(echo "$PERF" | grep -c "^‚Ä¢" 2>/dev/null || echo "0")
            CHORE_COUNT=$(echo "$CHORES" | grep -c "^‚Ä¢" 2>/dev/null || echo "0")
            
            # Build condensed version - show first 5 of each section
            CONDENSED=""
            
            # New Features
            if [ $FEATURE_COUNT -gt 0 ]; then
              HEADER=$(echo "$FEATURES" | grep "^\*\*" | head -1)
              ITEMS=$(echo "$FEATURES" | grep "^‚Ä¢" | head -5)
              CONDENSED="${CONDENSED}${HEADER}\n${ITEMS}\n"
              [ $FEATURE_COUNT -gt 5 ] && CONDENSED="${CONDENSED}*+ $((FEATURE_COUNT - 5)) more features*\n"
            fi
            
            # Bug Fixes
            if [ $FIX_COUNT -gt 0 ]; then
              HEADER=$(echo "$FIXES" | grep "^\*\*" | head -1)
              ITEMS=$(echo "$FIXES" | grep "^‚Ä¢" | head -5)
              CONDENSED="${CONDENSED}\n${HEADER}\n${ITEMS}\n"
              [ $FIX_COUNT -gt 5 ] && CONDENSED="${CONDENSED}*+ $((FIX_COUNT - 5)) more fixes*\n"
            fi
            
            # Refactors
            if [ $REFACTOR_COUNT -gt 0 ]; then
              HEADER=$(echo "$REFACTORS" | grep "^\*\*" | head -1)
              ITEMS=$(echo "$REFACTORS" | grep "^‚Ä¢" | head -5)
              CONDENSED="${CONDENSED}\n${HEADER}\n${ITEMS}\n"
              [ $REFACTOR_COUNT -gt 5 ] && CONDENSED="${CONDENSED}*+ $((REFACTOR_COUNT - 5)) more refactors*\n"
            fi
            
            # Style Changes
            if [ $STYLE_COUNT -gt 0 ]; then
              HEADER=$(echo "$STYLE" | grep "^\*\*" | head -1)
              ITEMS=$(echo "$STYLE" | grep "^‚Ä¢" | head -5)
              CONDENSED="${CONDENSED}\n${HEADER}\n${ITEMS}\n"
              [ $STYLE_COUNT -gt 5 ] && CONDENSED="${CONDENSED}*+ $((STYLE_COUNT - 5)) more style changes*\n"
            fi
            
            # Performance Improvements
            if [ $PERF_COUNT -gt 0 ]; then
              HEADER=$(echo "$PERF" | grep "^\*\*" | head -1)
              ITEMS=$(echo "$PERF" | grep "^‚Ä¢" | head -5)
              CONDENSED="${CONDENSED}\n${HEADER}\n${ITEMS}\n"
              [ $PERF_COUNT -gt 5 ] && CONDENSED="${CONDENSED}*+ $((PERF_COUNT - 5)) more improvements*\n"
            fi
            
            # Chores
            if [ $CHORE_COUNT -gt 0 ]; then
              HEADER=$(echo "$CHORES" | grep "^\*\*" | head -1)
              ITEMS=$(echo "$CHORES" | grep "^‚Ä¢" | head -5)
              CONDENSED="${CONDENSED}\n${HEADER}\n${ITEMS}\n"
              [ $CHORE_COUNT -gt 5 ] && CONDENSED="${CONDENSED}*+ $((CHORE_COUNT - 5)) more chores*\n"
            fi
            
            # Add link to full changelog
            CONDENSED="${CONDENSED}\nüìã [View full changelog on GitHub](https://github.com/${{ github.repository }}/releases/tag/${{ env.LATEST_TAG }})"
            
            DISCORD_NOTES="$CONDENSED"
            echo "Truncated to smart summary"
          fi
          
          echo "DISCORD_NOTES<<EOF" >> $GITHUB_ENV
          echo -e "$DISCORD_NOTES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Send Release Announcement to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          # Determine role mention based on release type
          if [[ "${{ env.LATEST_TAG }}" == *alpha* ]]; then
            role_mention=""
          elif [[ "${{ env.LATEST_TAG }}" == *beta* ]]; then
            role_mention="<@&YOUR_BETA_ROLE_ID>"
          else
            role_mention="<@&YOUR_RELEASE_ROLE_ID>"
          fi
          
          # Set color based on release type
          if [[ "${{ env.LATEST_TAG }}" == *alpha* ]]; then
            color=15844367  # Orange
          elif [[ "${{ env.LATEST_TAG }}" == *beta* ]]; then
            color=15105570  # Gold
          else
            color=1754421   # Green
          fi
          
          # Create Discord embed
          discord_data=$(jq -nc \
            --arg role "$role_mention" \
            --arg title "üöÄ New Release: ${{ env.LATEST_TAG }}" \
            --arg description "$DISCORD_NOTES" \
            --arg footer "AnimeStream ‚Ä¢ $(date -u +%Y-%m-%d)" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)" \
            --argjson color "$color" \
            --arg url "https://github.com/${{ github.repository }}/releases/tag/${{ env.LATEST_TAG }}" \
            '{"content":$role,"embeds":[{"title":$title,"description":$description,"color":$color,"url":$url,"footer":{"text":$footer},"timestamp":$timestamp}]}')
          
          # Send to Discord
          curl -H "Content-Type: application/json" \
            -X POST \
            -d "$discord_data" \
            "$DISCORD_WEBHOOK_URL"
          
          echo "‚úÖ Release announcement sent to Discord"

      - name: Send Download Links to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          # Build download message with proper newlines
          MESSAGE="## üì¶ **Download ${{ env.LATEST_TAG }}**"$'\n\n'
          
          # Android Section
          if [ -n "$APK_UNIVERSAL" ] || [ -n "$APK_ARM64" ] || [ -n "$APK_ARM32" ] || [ -n "$APK_X86" ]; then
            MESSAGE="${MESSAGE}**üì± Android**"$'\n'
            [ -n "$APK_UNIVERSAL" ] && MESSAGE="${MESSAGE}$APK_UNIVERSAL"$'\n'
            [ -n "$APK_ARM64" ] && MESSAGE="${MESSAGE}$APK_ARM64"$'\n'
            [ -n "$APK_ARM32" ] && MESSAGE="${MESSAGE}$APK_ARM32"$'\n'
            [ -n "$APK_X86" ] && MESSAGE="${MESSAGE}$APK_X86"$'\n'
            MESSAGE="${MESSAGE}"$'\n'
          fi
          
          # Windows Section
          if [ -n "$WINDOWS_SETUP" ] || [ -n "$WINDOWS_PORTABLE" ]; then
            MESSAGE="${MESSAGE}**ü™ü Windows**"$'\n'
            [ -n "$WINDOWS_SETUP" ] && MESSAGE="${MESSAGE}$WINDOWS_SETUP"$'\n'
            [ -n "$WINDOWS_PORTABLE" ] && MESSAGE="${MESSAGE}$WINDOWS_PORTABLE"$'\n'
            MESSAGE="${MESSAGE}"$'\n'
          fi
          
          # Linux Section
          if [ -n "$LINUX_DEB" ] || [ -n "$LINUX_RPM" ] || [ -n "$LINUX_FLATPAK" ] || [ -n "$LINUX_PORTABLE" ]; then
            MESSAGE="${MESSAGE}**üêß Linux**"$'\n'
            [ -n "$LINUX_DEB" ] && MESSAGE="${MESSAGE}$LINUX_DEB"$'\n'
            [ -n "$LINUX_RPM" ] && MESSAGE="${MESSAGE}$LINUX_RPM"$'\n'
            [ -n "$LINUX_FLATPAK" ] && MESSAGE="${MESSAGE}$LINUX_FLATPAK"$'\n'
            [ -n "$LINUX_PORTABLE" ] && MESSAGE="${MESSAGE}$LINUX_PORTABLE"$'\n'
            MESSAGE="${MESSAGE}"$'\n'
          fi
          
          # Add footer
          MESSAGE="${MESSAGE}[üìã View all assets on GitHub](https://github.com/${{ github.repository }}/releases/tag/${{ env.LATEST_TAG }})"
          
          # Create and send Discord message
          PAYLOAD=$(jq -n --arg content "$MESSAGE" '{"content":$content}')
          
          curl -X POST "$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"
          
          echo "‚úÖ Download links sent to Discord"

      - name: Send Summary
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚úÖ Release notification completed!"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìã Release: ${{ env.LATEST_TAG }}"
          echo "üì¶ Assets sent to Discord:"
          [ -n "$APK_UNIVERSAL" ] && echo "   ‚úì Android APKs"
          [ -n "$WINDOWS_SETUP" ] && echo "   ‚úì Windows builds"
          [ -n "$LINUX_DEB" ] && echo "   ‚úì Linux packages"
          echo "üîó Release: https://github.com/${{ github.repository }}/releases/tag/${{ env.LATEST_TAG }}"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
